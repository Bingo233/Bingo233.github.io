<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pantsu&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-05T04:47:25.275Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Pantsu-It</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试问题总结（二）</title>
    <link href="http://yoursite.com/2016/04/04/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/04/面试问题总结（二）/</id>
    <published>2016-04-04T14:23:01.000Z</published>
    <updated>2016-04-05T04:47:25.275Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这里总结了一些舍友的面经，一是为了补查只是漏洞，而是为接下来的面试做准备~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Java] 各种 XXXMap 的底层实现~ （听说这个是面Android时遇到的问题蛤 O.O）&lt;/li&gt;
&lt;li&gt;[操作系统] 进程状态的转换/&lt;/li&gt;
&lt;li&gt;[计网] 七层协议/三次握手过程/网关是怎么区分内网不同的机器的/内部的机器的IP与外界交互的过程是什么/端口的作用/迅雷如何实现限速/&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这里总结了一些舍友的面经，一是为了补查只是漏洞，而是为接下来的面试做准备~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Java] 各种 XXXMap 的底层实现~ （听说这个是面Android时遇到的问题蛤 O.O）&lt;/li&gt;
&lt;li&gt;[操作系统] 进程状态的转换/&lt;/li&gt;
&lt;li&gt;[计网] 七层协议/三次握手过程/网关是怎么区分内网不同的机器的/内部的机器的IP与外界交互的过程是什么/端口的作用/迅雷如何实现限速/&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>笔试问题总结（一）</title>
    <link href="http://yoursite.com/2016/04/04/%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/04/笔试问题总结（一）/</id>
    <published>2016-04-04T04:01:11.000Z</published>
    <updated>2016-04-05T04:18:30.862Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;昨晚做了 &lt;strong&gt;腾讯-移动端&lt;/strong&gt; 的笔试，包括选择题和问答题。&lt;/p&gt;
&lt;p&gt;选择题主要有c++，数据库，数据结构，ios/android;&lt;/p&gt;
&lt;p&gt;问答题共四道：两道编程题（字符串处理，动态规划）不是很难，一道关于PVP游戏技术方面的开放性问题，一道关于Android中AsynTask底层的代码题。&lt;/p&gt;
&lt;p&gt;挑一些重要的说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[DB] 在一组数据的int字段（包含有null值）上排序的结果集 &lt;/li&gt;
&lt;li&gt;[Android] 关于Android 的垃圾回收机制&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;数据库中NULL的排序（比较）问题&quot;&gt;&lt;a href=&quot;#数据库中NULL的排序（比较）问题&quot; class=&quot;headerlink&quot; title=&quot;数据库中NULL的排序（比较）问题&quot;&gt;&lt;/a&gt;数据库中NULL的排序（比较）问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在数据库中，判定是否为null的语句是 is (not) null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_ne1.png&quot; alt=&quot;测试一&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_ne2.png&quot; alt=&quot;测试二&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_ne3.png&quot; alt=&quot;测试三&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于Android-的垃圾回收机制&quot;&gt;&lt;a href=&quot;#关于Android-的垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;关于Android 的垃圾回收机制&quot;&gt;&lt;/a&gt;关于Android 的垃圾回收机制&lt;/h1&gt;&lt;p&gt;关于&lt;strong&gt;Android - GC&lt;/strong&gt;出现了两个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在GC发生时，会暂停Activity/Service的运行？&lt;/li&gt;
&lt;li&gt;在GC_EXPLICIT发生时，软引用会被清除？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了了解Android的GC 过程，参考以下文章：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/41822747&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dalvik虚拟机垃圾收集（GC）过程分析&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;昨晚做了 &lt;strong&gt;腾讯-移动端&lt;/strong&gt; 的笔试，包括选择题和问答题。&lt;/p&gt;
&lt;p&gt;选择题主要有c++，数据库，数据结构，ios/android;&lt;/p&gt;
&lt;p&gt;问答题共四道：两道编程题（字符串处理，动态规划）不是很难，一道关于PVP游戏技术方面的开放性问题，一道关于Android中AsynTask底层的代码题。&lt;/p&gt;
&lt;p&gt;挑一些重要的说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[DB] 在一组数据的int字段（包含有null值）上排序的结果集 &lt;/li&gt;
&lt;li&gt;[Android] 关于Android 的垃圾回收机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>面试问题总结（一）</title>
    <link href="http://yoursite.com/2016/03/27/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/27/面试问题总结（一）/</id>
    <published>2016-03-27T04:11:24.000Z</published>
    <updated>2016-03-29T05:17:23.090Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;根据一位舍友在之前去&lt;strong&gt;阿里&lt;/strong&gt;面试所带来的反馈，以下总结几个有些深入、但不算困难的技术问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Java] StringBuilder 和 StringBuffer 的区别 &lt;/li&gt;
&lt;li&gt;[算法] 快速排序如何优化&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;StringBuilder-和-StringBuffer-的区别&quot;&gt;&lt;a href=&quot;#StringBuilder-和-StringBuffer-的区别&quot; class=&quot;headerlink&quot; title=&quot;StringBuilder 和 StringBuffer 的区别&quot;&gt;&lt;/a&gt;StringBuilder 和 StringBuffer 的区别&lt;/h1&gt;&lt;h2 id=&quot;相同点：&quot;&gt;&lt;a href=&quot;#相同点：&quot; class=&quot;headerlink&quot; title=&quot;相同点：&quot;&gt;&lt;/a&gt;相同点：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;首先，二者都是在各自的生成器内部维护了一个可变容量的字符数组缓冲区；&lt;/p&gt;
&lt;p&gt;然后，二者都是利用 &lt;strong&gt;insert&lt;/strong&gt; 和 &lt;strong&gt;append&lt;/strong&gt; 方法对缓冲区进行操作；&lt;/p&gt;
&lt;p&gt;还有就是， 二者在字符序列的长度超过缓冲区容量时，容量会自动增长。&lt;/p&gt;
&lt;h2 id=&quot;不同点：&quot;&gt;&lt;a href=&quot;#不同点：&quot; class=&quot;headerlink&quot; title=&quot;不同点：&quot;&gt;&lt;/a&gt;不同点：&lt;/h2&gt;&lt;p&gt;StringBuffer是线程安全的，即内部执行同步；&lt;/p&gt;
&lt;p&gt;而StringBuider是从JDK5开始为StringBuffer补充的非同步实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Java中线程安全和非线程安全的类&quot;&gt;&lt;a href=&quot;#Java中线程安全和非线程安全的类&quot; class=&quot;headerlink&quot; title=&quot;Java中线程安全和非线程安全的类&quot;&gt;&lt;/a&gt;Java中线程安全和非线程安全的类&lt;/h1&gt;&lt;p&gt;常见的有： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;与 &lt;strong&gt;Vector&lt;/strong&gt;(可变数组，同步故效率低)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;,&lt;strong&gt;HashSet&lt;/strong&gt;等（非同步）与 &lt;strong&gt;Hashtable&lt;/strong&gt;(同步)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到线程安全，不得不提的是 Java中的 &lt;strong&gt;java.util.concurrent&lt;/strong&gt; 这个包！ 它为&lt;strong&gt;并发编程&lt;/strong&gt;提供了强大的辅助工具类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Executors&lt;/strong&gt;四种简单方法创建 &lt;strong&gt;ExecutorService&lt;/strong&gt; ：newCachedThreadPool、newFixSizeThreadExecutor、newScheduledExecutor、newSingleThreadExecutor；&lt;/p&gt;
&lt;p&gt;可执行由 Callable 表示的任何函数，Future 返回函数的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;java.util.concurrent &lt;em&gt;ConcurrentLinkedQueue&lt;/em&gt; 类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent 中的五个实现都支持扩展的 &lt;em&gt;BlockingQueue&lt;/em&gt; 接口，该接口定义了 put 和 take 的阻塞版本：&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;、&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;、&lt;strong&gt;SynchronousQueue&lt;/strong&gt;、&lt;br&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt; 和 &lt;strong&gt;DelayQueue&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TimeUnit&lt;/strong&gt; 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;四个类可协助实现常见的专用同步语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Semaphore&lt;/strong&gt; 是一个经典的并发工具，和c中的信号量一致。 &lt;strong&gt;CountDownLatch&lt;/strong&gt;是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。 &lt;strong&gt;CyclicBarrier&lt;/strong&gt; 是一个可重置的多路同步点，在某些并行编程风格中很有用。 &lt;strong&gt;Exchanger&lt;/strong&gt; 允许两个线程在集合点交换对象，它在多流水线设计中是有用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除队列外，此包还提供了几个设计用于多线程上下文中的 Collection 实现：&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;、&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt; 和 &lt;strong&gt;CopyOnWriteArraySet&lt;/strong&gt;。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(&lt;em&gt;以下摘自百度&lt;/em&gt;) 此包中与某些类一起使用的“Concurrent&amp;amp;rdquo前缀;是一种简写，表明与类似的“同步”类有所不同。例如，&lt;strong&gt;java.util.Hashtable&lt;/strong&gt; 和 &lt;strong&gt;Collections.synchronizedMap(new HashMap())&lt;/strong&gt; 是同步的，但 &lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; 则是“并发的”。并发集合是线程安全的，但是不受单个排他锁定的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁定阻止对集合的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共集合的其他情况中，通常“并发”版本要更好一些。当集合是未共享的，或者仅保持其他锁定时集合是可访问的情况下，非同步集合则要更好一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了弱一致的&lt;/strong&gt;，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结集合，所以它不一定反映自迭代器创建以来的所有更新。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;快速排序如何优化&quot;&gt;&lt;a href=&quot;#快速排序如何优化&quot; class=&quot;headerlink&quot; title=&quot;快速排序如何优化&quot;&gt;&lt;/a&gt;快速排序如何优化&lt;/h1&gt;&lt;p&gt;这个问题突然一听感觉无从下手，（啊嘞？快排不是最快的基于比较的排序算法吗！）这里注意： 快排只是平均速度最快，达到O(nlogn)，而最坏情况下（已经排序好的输入下）达到O(n²)，接近于冒泡排序！ 因此，改进对最快情况的处理就可以优化快速排序啦~&lt;/p&gt;
&lt;p&gt;主要参考了&lt;strong&gt;&lt;a href=&quot;http://www.blogjava.net/killme2008/archive/2010/09/08/quicksort_optimized.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;快速排序及优化&lt;/a&gt;&lt;/strong&gt;，这篇文章分析的很全面~&lt;/p&gt;
&lt;h2 id=&quot;P1版本：基础&quot;&gt;&lt;a href=&quot;#P1版本：基础&quot; class=&quot;headerlink&quot; title=&quot;P1版本：基础&quot;&gt;&lt;/a&gt;P1版本：基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;选择左端点（或右断点）为pivot, 遍历数组元素与pivot进行比较并将较小交换至左边，最后将左端点（或右断点）交换到中间位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;P2版本：优化排序好数组的情况&quot;&gt;&lt;a href=&quot;#P2版本：优化排序好数组的情况&quot; class=&quot;headerlink&quot; title=&quot;P2版本：优化排序好数组的情况&quot;&gt;&lt;/a&gt;P2版本：优化排序好数组的情况&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;随机选取pivot，即随机交换左端点与数组中一点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;P3版本：更高效的划分方法&quot;&gt;&lt;a href=&quot;#P3版本：更高效的划分方法&quot; class=&quot;headerlink&quot; title=&quot;P3版本：更高效的划分方法&quot;&gt;&lt;/a&gt;P3版本：更高效的划分方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用两个索引i,j，即从左边寻找大于pivot的元素，从右边寻找pivot的元素，交换这两个元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;P4-P5版本：在排序好数组情况下，快排为O-n²-，插入排序为O-n&quot;&gt;&lt;a href=&quot;#P4-P5版本：在排序好数组情况下，快排为O-n²-，插入排序为O-n&quot; class=&quot;headerlink&quot; title=&quot;P4/P5版本：在排序好数组情况下，快排为O(n²)，插入排序为O(n)&quot;&gt;&lt;/a&gt;P4/P5版本：在排序好数组情况下，快排为O(n²)，插入排序为O(n)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果序列规模足够小，使用插入排序替代快速排序&lt;/p&gt;
&lt;p&gt;或者序列规模足够小时直接返回，（这个时候整个数组是由一个一个没有排序的子序列按照顺序组成的），然后进行一遍插入排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;P6版本：优化pivot的选取（因为P2版本中随机数生成器开销很大）&quot;&gt;&lt;a href=&quot;#P6版本：优化pivot的选取（因为P2版本中随机数生成器开销很大）&quot; class=&quot;headerlink&quot; title=&quot;P6版本：优化pivot的选取（因为P2版本中随机数生成器开销很大）&quot;&gt;&lt;/a&gt;P6版本：优化pivot的选取（因为P2版本中随机数生成器开销很大）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，大小小于7的数组则直接使用插入排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;P7版本：将P3版本中的”fat-partition”改进为”split-end”&quot;&gt;&lt;a href=&quot;#P7版本：将P3版本中的”fat-partition”改进为”split-end”&quot; class=&quot;headerlink&quot; title=&quot;P7版本：将P3版本中的”fat-partition”改进为”split-end”&quot;&gt;&lt;/a&gt;P7版本：将P3版本中的”fat-partition”改进为”split-end”&lt;/h2&gt;&lt;p&gt;之前的做法是将大于等于或小于等于pivot的元素交换到两边，中间剩余pivot: &lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_me6.png&quot; alt=&quot;fat-partition&quot;&gt;&lt;/p&gt;
&lt;p&gt;Arrays.sort()所采用的做法进行两端扫描，但是遇到等于pivot的元素不是进行互换，而是各自交换到两端。当扫描结束，还要将两端这些跟pivot equals的元素交换到中间位置，不相同的元素交换到两端，左边仍然是比pivot小的，右边是比pivot大的，分别进行递归的快速排序处理:   (虽然看上去增加了交换的次数，但与pivot相等的元素就不会被重复处理~) &lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_me5.png&quot; alt=&quot;splite-end&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;其他排序的优化&quot;&gt;&lt;a href=&quot;#其他排序的优化&quot; class=&quot;headerlink&quot; title=&quot;其他排序的优化&quot;&gt;&lt;/a&gt;其他排序的优化&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;设置flag，当比较时发现没有进行交换，即已经排序好，就跳出循环~&lt;/p&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;每遍遍历后，同时选出min和max，分别交换到left和right（如果先交换min和left，注意在max==left的情况下，交换后要更新max为min）&lt;/p&gt;
&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;h3 id=&quot;查找优化&quot;&gt;&lt;a href=&quot;#查找优化&quot; class=&quot;headerlink&quot; title=&quot;查找优化&quot;&gt;&lt;/a&gt;查找优化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在有序区中查找新元素插入位置时，为了减少元素比较次数提高效率，采用&lt;strong&gt;二分查找算法&lt;/strong&gt;进行插入位置的确定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分治优化（希尔排序）&quot;&gt;&lt;a href=&quot;#分治优化（希尔排序）&quot; class=&quot;headerlink&quot; title=&quot;分治优化（希尔排序）&quot;&gt;&lt;/a&gt;分治优化（希尔排序）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;具体如下（实现为升序）：&lt;br&gt;1.先取一个小于n的整数d1作为第一个增量，将所有距离为d1的倍数的记录放在同一个组中，把无序数组分割为若干个子序列。&lt;br&gt;2.在各子序列内进行直接插入排序。&lt;br&gt;3.然后取第二个增量d2&amp;lt;d1，重复步骤1~2，直至所取的增量dt=1(dt&amp;lt;dt-l&amp;lt;…&amp;lt;d2&amp;lt;d1)，即所有记录放在同一组中进行直接插入排序为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog_me4.png&quot; alt=&quot;希尔排序&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增量选取：希尔排序的时间复杂度与增量的选取有关，但是现今仍然没有人能找出希尔排序的精确下界。一般的选择原则是：取上一个增量的一半作为此次序列的划分增量。首次选择序列长度的一半为增量。（因此也叫缩小增量排序）&lt;/li&gt;
&lt;li&gt;希尔排序是不稳定的。因为在进行分组时，相同元素可能分到不同组中，改变相同元素的相对顺序。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;根据一位舍友在之前去&lt;strong&gt;阿里&lt;/strong&gt;面试所带来的反馈，以下总结几个有些深入、但不算困难的技术问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Java] StringBuilder 和 StringBuffer 的区别 &lt;/li&gt;
&lt;li&gt;[算法] 快速排序如何优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 滑动解决方案—ViewDragHelper, VelocityTracker, Scroller</title>
    <link href="http://yoursite.com/2016/03/24/Android%20%E6%BB%91%E5%8A%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94ViewDragHelper,%20VelocityTracker,%20Scroller/"/>
    <id>http://yoursite.com/2016/03/24/Android 滑动解决方案—ViewDragHelper, VelocityTracker, Scroller/</id>
    <published>2016-03-24T03:45:22.000Z</published>
    <updated>2016-03-24T04:33:50.777Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这两天在深入研究 拖了很久的、一直困扰我的 &lt;strong&gt;滑动问题&lt;/strong&gt;，之前略做过一些复杂的滑动冲突处理，但是有些滑动实现起来依然困难重重，比如这次的Demo中的第一个目标是实现 &lt;strong&gt;课程格子&lt;/strong&gt; 中课程列表的多向滑动，利用双层嵌套ScrollView的做法在处理 &lt;strong&gt;滑动冲突&lt;/strong&gt; 时较为复杂，而使用 &lt;strong&gt;ViewDragHelper&lt;/strong&gt; 使我在数分钟之内就实现了比嵌套更好的效果~ &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;献上我的膝盖 - Github&lt;/strong&gt;： &lt;a href=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; title=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Pantsu-It/ProjectForLearn&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;滑动分析&quot;&gt;&lt;a href=&quot;#滑动分析&quot; class=&quot;headerlink&quot; title=&quot;滑动分析&quot;&gt;&lt;/a&gt;滑动分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;课程格子：&lt;/strong&gt;课程列表的多向滑动 + 隐藏上栏的滑动收缩  （已实现）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小米时钟：&lt;/strong&gt;全局滑动相应 + 下部列表的滑动收缩 （待实现）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;QQ主界面：&lt;/strong&gt;左侧类似DrawerLayout的滑出 + 聊天列表Item-左滑显示操作按钮 （待实现）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;知乎主界面：&lt;/strong&gt;推送列表Item-左滑删除 + [原]子界面右滑回退 （待实现）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;滑动实例&quot;&gt;&lt;a href=&quot;#滑动实例&quot; class=&quot;headerlink&quot; title=&quot;滑动实例&quot;&gt;&lt;/a&gt;滑动实例&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这两天在深入研究 拖了很久的、一直困扰我的 &lt;strong&gt;滑动问题&lt;/strong&gt;，之前略做过一些复杂的滑动冲突处理，但是有些滑动实现起来依然困难重重，比如这次的Demo中的第一个目标是实现 &lt;strong&gt;课程格子&lt;/strong&gt; 中课程列表的多向滑动，利用双层嵌套ScrollView的做法在处理 &lt;strong&gt;滑动冲突&lt;/strong&gt; 时较为复杂，而使用 &lt;strong&gt;ViewDragHelper&lt;/strong&gt; 使我在数分钟之内就实现了比嵌套更好的效果~ &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="滑动" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android 图标角标数字显示—未读通知</title>
    <link href="http://yoursite.com/2016/03/22/Android%20%E5%9B%BE%E6%A0%87%E8%A7%92%E6%A0%87%E6%95%B0%E5%AD%97%E6%98%BE%E7%A4%BA%E2%80%94%E6%9C%AA%E8%AF%BB%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/2016/03/22/Android 图标角标数字显示—未读通知/</id>
    <published>2016-03-22T05:53:22.000Z</published>
    <updated>2016-03-22T08:23:25.519Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;很久以前就注意到像QQ、微信、短信、电话等一些应用会在桌面的右上角显示未读消息等等，曾经寻找过解决办法，很多博客上提到使用 &lt;strong&gt;桌面小插件&lt;/strong&gt; 来实现，我也尝试过用自定义图片实现的 &lt;strong&gt;快捷方式&lt;/strong&gt;，但这些方法都有各自的局限性，或者说和真实情况效果不符！ &lt;strong&gt;① 因为在手机桌面测试微信图标的拖动删除时，会提示卸载微信APP;&lt;/strong&gt; 而这种效果不论是&lt;strong&gt;桌面小插件&lt;/strong&gt; 或是 &lt;strong&gt;快捷方式&lt;/strong&gt; 都很难实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;献上我的膝盖 - Github&lt;/strong&gt;： &lt;a href=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; title=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Pantsu-It/ProjectForLearn&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;尝试&quot;&gt;&lt;a href=&quot;#尝试&quot; class=&quot;headerlink&quot; title=&quot;尝试&quot;&gt;&lt;/a&gt;尝试&lt;/h1&gt;&lt;h2 id=&quot;重写-Launcher&quot;&gt;&lt;a href=&quot;#重写-Launcher&quot; class=&quot;headerlink&quot; title=&quot;重写 Launcher&quot;&gt;&lt;/a&gt;重写 Launcher&lt;/h2&gt;&lt;p&gt;网上提到这种办法是让开发者写一个第三方的 &lt;strong&gt;Launcher&lt;/strong&gt;，（所谓Launcher就是负责绘制桌面APP图标的系统程序，他将检测到所有的设置为&lt;em&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;&gt;&lt;/category&gt;&lt;/em&gt;的Activity），然而对于第三方APP开发者，这种方法不可行。&lt;/p&gt;
&lt;h2 id=&quot;使用-Activity-Alias&quot;&gt;&lt;a href=&quot;#使用-Activity-Alias&quot; class=&quot;headerlink&quot; title=&quot;使用 Activity-Alias&quot;&gt;&lt;/a&gt;使用 Activity-Alias&lt;/h2&gt;&lt;p&gt;我尝试的第三种方式是通过在代码中动态 启用/禁用 &lt;strong&gt;Activity-Alias&lt;/strong&gt;，这次实现了&lt;strong&gt;效果①&lt;/strong&gt;，但缺点是一个&lt;strong&gt;Activity-Alias&lt;/strong&gt;在Manifest.xml中静态绑定一个drawable图片，如果要显示1-100条未读通知的范围，就必须创建 &lt;strong&gt;100个Activity-Alias&lt;/strong&gt;，而且更换速度很慢，不能“即时”更新角标数字。&lt;/p&gt;
&lt;h2 id=&quot;使用-第三方ROM定义的广播&quot;&gt;&lt;a href=&quot;#使用-第三方ROM定义的广播&quot; class=&quot;headerlink&quot; title=&quot;使用 第三方ROM定义的广播&quot;&gt;&lt;/a&gt;使用 第三方ROM定义的广播&lt;/h2&gt;&lt;p&gt;幸运的是，我在网上找到了一篇文章 &lt;a href=&quot;&quot;&gt;Badge分析&amp;amp;如何逼死处女座&lt;/a&gt;，文章中提到了有些厂家（包括三星，LG，小米）的第三方ROM支持通过发送广播来设置 Badge，实现原生ROM支持的未读短信数的效果。  以 &lt;strong&gt;MIUI系统&lt;/strong&gt; 为例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 向小米手机发送未读消息数广播&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@TargetApi&lt;/span&gt;(Build.VERSION_CODES.JELLY_BEAN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendToXiaoMi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 设置MIUI的Badge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; context context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; count count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Log.d(&lt;span class=&quot;string&quot;&gt;&quot;xys&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Launcher : MIUI&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(context, MainActivity.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PendingIntent contentIntent = PendingIntent.getActivity(context, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, intent, PendingIntent.FLAG_UPDATE_CURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Notification.Builder builder =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Notification.Builder(context)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .setContentTitle(&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .setContentText(&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .setSmallIcon(R.mipmap.ic_launcher)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .setContentIntent(contentIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .setAutoCancel(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Notification notification = builder.build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Field field = notification.getClass().getDeclaredField(&lt;span class=&quot;string&quot;&gt;&quot;extraNotification&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object extraNotification = field.get(notification);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method method = extraNotification.getClass().getDeclaredMethod(&lt;span class=&quot;string&quot;&gt;&quot;setMessageCount&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        method.invoke(extraNotification, count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mNotificationManager.notify(id, notification);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 取消向小米手机发送未读消息数广播&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cancelOfXiaoMi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NotificationManager manger = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    manger.cancel(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;很久以前就注意到像QQ、微信、短信、电话等一些应用会在桌面的右上角显示未读消息等等，曾经寻找过解决办法，很多博客上提到使用 &lt;strong&gt;桌面小插件&lt;/strong&gt; 来实现，我也尝试过用自定义图片实现的 &lt;strong&gt;快捷方式&lt;/strong&gt;，但这些方法都有各自的局限性，或者说和真实情况效果不符！ &lt;strong&gt;① 因为在手机桌面测试微信图标的拖动删除时，会提示卸载微信APP;&lt;/strong&gt; 而这种效果不论是&lt;strong&gt;桌面小插件&lt;/strong&gt; 或是 &lt;strong&gt;快捷方式&lt;/strong&gt; 都很难实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="图标" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义View—动态图播放</title>
    <link href="http://yoursite.com/2016/03/17/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E5%8A%A8%E6%80%81%E5%9B%BE%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2016/03/17/Android 自定义View—动态图播放/</id>
    <published>2016-03-17T06:58:57.000Z</published>
    <updated>2016-03-22T06:03:17.518Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在《Android开发艺术探索》一书中，讲到自定义View和ViewGroup的方法，之后在 极客学院 学习了 &lt;a href=&quot;http://www.jikexueyuan.com/course/1928.html&quot; title=&quot;http://www.jikexueyuan.com/course/1928.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自定义View—实现动态图播放&lt;/a&gt; 之后，参照ImageView的源码，对自定义组件GifView进行了一下改动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 &lt;strong&gt;scaleType&lt;/strong&gt; 属性&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;Matrix&lt;/strong&gt; 变换图像&lt;/li&gt;
&lt;li&gt;实现了播放 开始/暂停 的功能&lt;/li&gt;
&lt;li&gt;实现了对Canvas的二级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;献上我的膝盖 - Github&lt;/strong&gt;： &lt;a href=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; title=&quot;https://github.com/Pantsu-It/ProjectForLearn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Pantsu-It/ProjectForLearn&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础实现&quot;&gt;&lt;a href=&quot;#基础实现&quot; class=&quot;headerlink&quot; title=&quot;基础实现&quot;&gt;&lt;/a&gt;基础实现&lt;/h1&gt;&lt;p&gt;自定义View实现主要是重写 onMeasure() 和 onDraw() 两个方法:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMeasure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; heightMeasureSpec)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDraw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Canvas canvas)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;strong&gt;onMeasure()&lt;/strong&gt; 方法负责通过父级组件传入的两个参数计算得到并设置正确的宽高值，&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自定义部件建议加入一下两行代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w = Math.max(w, getSuggestedMinimumWidth());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h = Math.max(h, getSuggestedMinimumHeight());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;widthSize = resolveSizeAndState(w, widthMeasureSpec, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;heightSize = resolveSizeAndState(w, heightMeasureSpec, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ratioWidth = (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;) widthSize / w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ratioHeight = (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;) heightSize / h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setMeasuredDimension(widthSize, heightSize);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;onDraw()&lt;/strong&gt; 方法 负责绘制自己的图像。&lt;/p&gt;
&lt;p&gt;另外有两个方法与以上两个方法分别对应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;requestLayout()&lt;/strong&gt;方法会使组件重新调用onMeasure()方法进行‘测量’&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;invalidate()&lt;/strong&gt;方法会使组件调用onDraw()方法进行‘重绘’&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xs3wx.com1.z0.glb.clouddn.com/blog2015-3-21.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;进阶实现&quot;&gt;&lt;a href=&quot;#进阶实现&quot; class=&quot;headerlink&quot; title=&quot;进阶实现&quot;&gt;&lt;/a&gt;进阶实现&lt;/h1&gt;&lt;h2 id=&quot;增加-ScaleType-属性&quot;&gt;&lt;a href=&quot;#增加-ScaleType-属性&quot; class=&quot;headerlink&quot; title=&quot;增加 ScaleType 属性&quot;&gt;&lt;/a&gt;增加 ScaleType 属性&lt;/h2&gt;&lt;p&gt;在ImageView的源码中，ScaleType作为一个内部枚举类，为ImageView提供了七种缩放类型，其中ScaleType.MATRIX最为灵活，可以通过setImageMatrix(Matrix matrix)方法设定自定义的矩阵变换。&lt;br&gt;主要思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在onMeasure()方法中取得图片相对空间宽高的比例&lt;/li&gt;
&lt;li&gt;在 configureMatrix()方法中计算并获得变换矩阵mScaleMatrix&lt;/li&gt;
&lt;li&gt;在 onDraw()方法中通过 canvas.cancat(mScaleMatrix)应用矩阵变换 &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用Matrix变换&quot;&gt;&lt;a href=&quot;#使用Matrix变换&quot; class=&quot;headerlink&quot; title=&quot;使用Matrix变换&quot;&gt;&lt;/a&gt;使用Matrix变换&lt;/h2&gt;&lt;p&gt;最开始并没有想到用Matrix来实施变换，只是用一些canvas的简单方法：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;canvas.scale()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.translate()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.skew()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.rotate()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后来在做多重变换时就无法满足要求，参考了ImageView源码后决定采用Matrix:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;matrix.setScale()  matrix.setTranslate() matrix.setXXX()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix.preScale()  matrix.preTranslate() ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix.postXXX()   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix.setConcat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix.preConcat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix.postConcat()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;Matrix的 preXXX()方法和 postXXX()方法曾经让我疑惑，例如 preScale()方法：&lt;/p&gt;
&lt;p&gt;从线代计算角度来看，matrixA.preScale(b1, b2)表示前乘一个Scale操作的矩阵MatrixB，&lt;/p&gt;
&lt;p&gt;而效果上是将 MatrixB操作至于MatrixA之前，即 MatrixA –&amp;gt; MatrixB –&amp;gt; 。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Preconcats the matrix with the specified scale.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * M&#39; = M * S(sx, sy)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preScale&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; sx, &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; sy)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	native_preScale(native_instance, sx, sy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，MatrixA.set(MatrixB)会清空之前的矩阵序列，结果是只剩下 MatrixB –&amp;gt; 。&lt;/p&gt;
&lt;h2 id=&quot;实现-暂停播放&quot;&gt;&lt;a href=&quot;#实现-暂停播放&quot; class=&quot;headerlink&quot; title=&quot;实现 暂停播放&quot;&gt;&lt;/a&gt;实现 暂停播放&lt;/h2&gt;&lt;p&gt;解析Gif图片的基本原理就是用 &lt;strong&gt;android.graphics.Movie&lt;/strong&gt; 类加载图片文件数据流，并通过 &lt;strong&gt;mMovie.setTime(long time)&lt;/strong&gt; 设定时间点，在 &lt;strong&gt;mMovie.draw(Canvas, 0, 0)&lt;/strong&gt; 时将时间点 &lt;strong&gt;time&lt;/strong&gt; 处的图像绘制到 &lt;strong&gt;canvas&lt;/strong&gt; 上，因此，只要在暂停时保存断点 &lt;strong&gt;time&lt;/strong&gt; 并在播放时恢复断点 &lt;strong&gt;time&lt;/strong&gt;即可~&lt;/p&gt;
&lt;h2 id=&quot;Canvas-二级缓存&quot;&gt;&lt;a href=&quot;#Canvas-二级缓存&quot; class=&quot;headerlink&quot; title=&quot;Canvas 二级缓存&quot;&gt;&lt;/a&gt;Canvas 二级缓存&lt;/h2&gt;&lt;p&gt;在想到为了预览或者实现QQ滑动时暂停播放的效果，有必要实现暂停播放，而此时在onDraw(Canvas canvas)方法重绘过程中依旧会通过 mMovie 解析数据流，因此有必要实现双缓冲来对绘制实现优化：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化用于缓冲的 Bitmap 和 Canvas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheBitmap == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cacheBitmap = Bitmap.createBitmap(widthSize, heightSize, Bitmap.Config.ARGB_8888);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cacheCanvas = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Canvas(cacheBitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当图像更新时，mMovie将通过cacheCanvas绘制到cacheBitmap上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mMovie.draw(cacheCanvas, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// canvas绘制cacheBitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.drawBitmap(cacheBitmap, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Paint());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在使用Movie绘制时，即 &lt;strong&gt;mMovie.draw(canvas, 0, 0)&lt;/strong&gt; 时Log显示“fatal error”, 在查阅了 &lt;a href=&quot;http://stackoverflow.com/questions/29816897/android-fatal-signal-11-sigsegv-at-0x00000000-code-1-on-movie-draw&quot; title=&quot;http://stackoverflow.com/questions/29816897/android-fatal-signal-11-sigsegv-at-0x00000000-code-1-on-movie-draw&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stack overflow&lt;/a&gt; 后得知，必须&lt;strong&gt;关闭硬件加速&lt;/strong&gt;才能正常运行… &amp;lt;尚未解决&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;strong&gt;onDraw(Canvas canvas)&lt;/strong&gt; 方法中调用 &lt;strong&gt;canvas.setMatrix(matrix)&lt;/strong&gt; 导致图像显示异常，之后更换代码为 &lt;strong&gt;canvas.concatMatrix(matrix)&lt;/strong&gt; 问题解决~ &lt;br&gt;&lt;br&gt;猜测: 父级容器将设定好内置Matrix的canvas传递给各个子组件让其绘制自己，而问题代码覆盖了内置Matrix Orz~&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;后续版本&quot;&gt;&lt;a href=&quot;#后续版本&quot; class=&quot;headerlink&quot; title=&quot;后续版本&quot;&gt;&lt;/a&gt;后续版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;尝试兼容一般图片 【已尝试过使用 Movie类 解析静态图片的数据流，返回为null&lt;/li&gt;
&lt;li&gt;在onMeasure()方法中，让View支持 &lt;strong&gt;wrap_content&lt;/strong&gt; 属性&lt;/li&gt;
&lt;li&gt;在onDraw()方法中，处理 &lt;strong&gt;padding&lt;/strong&gt; 属性&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在《Android开发艺术探索》一书中，讲到自定义View和ViewGroup的方法，之后在 极客学院 学习了 &lt;a href=&quot;http://www.jikexueyuan.com/course/1928.html&quot; title=&quot;http://www.jikexueyuan.com/course/1928.html&quot;&gt;自定义View—实现动态图播放&lt;/a&gt; 之后，参照ImageView的源码，对自定义组件GifView进行了一下改动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 &lt;strong&gt;scaleType&lt;/strong&gt; 属性&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;Matrix&lt;/strong&gt; 变换图像&lt;/li&gt;
&lt;li&gt;实现了播放 开始/暂停 的功能&lt;/li&gt;
&lt;li&gt;实现了对Canvas的二级缓存&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="组件" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/02/17/hello-world/"/>
    <id>http://yoursite.com/2016/02/17/hello-world/</id>
    <published>2016-02-17T06:58:57.000Z</published>
    <updated>2016-03-22T04:28:08.724Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;h5 id=&quot;在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot;&gt;&lt;a href=&quot;#在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot; class=&quot;headerlink&quot; title=&quot;在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot;&gt;&lt;/a&gt;在萌萌哒的舍友&lt;a href=&quot;&quot;&gt;丛九九&lt;/a&gt;的协助下，终于在学期开始搭好了自己的博客。&lt;/h5&gt;&lt;h5 id=&quot;感觉博客还缺点功能、少点链接什么的，会再改一改&quot;&gt;&lt;a href=&quot;#感觉博客还缺点功能、少点链接什么的，会再改一改&quot; class=&quot;headerlink&quot; title=&quot;感觉博客还缺点功能、少点链接什么的，会再改一改~&quot;&gt;&lt;/a&gt;感觉博客还缺点功能、少点链接什么的，会再改一改~&lt;/h5&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h5 id=&quot;以前学习Android写一些小组件什么的，会把感想或总结写在为知笔记里。&quot;&gt;&lt;a href=&quot;#以前学习Android写一些小组件什么的，会把感想或总结写在为知笔记里。&quot; class=&quot;headerlink&quot; title=&quot;以前学习Android写一些小组件什么的，会把感想或总结写在为知笔记里。&quot;&gt;&lt;/a&gt;以前学习Android写一些小组件什么的，会把感想或总结写在为知笔记里。&lt;/h5&gt;&lt;h5 id=&quot;有了博客的话，会逐渐向这边转移的&quot;&gt;&lt;a href=&quot;#有了博客的话，会逐渐向这边转移的&quot; class=&quot;headerlink&quot; title=&quot;有了博客的话，会逐渐向这边转移的~&quot;&gt;&lt;/a&gt;有了博客的话，会逐渐向这边转移的~&lt;/h5&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;h5 id=&quot;在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot;&gt;&lt;a href=&quot;#在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot; class=&quot;headerlink&quot; title=&quot;在萌萌哒的舍友丛九九的协助下，终于在学期开始搭好了自己的博客。&quot;&gt;&lt;/a&gt;在萌萌哒的舍友&lt;a href=&quot;&quot;&gt;丛九九&lt;/a&gt;的协助下，终于在学期开始搭好了自己的博客。&lt;/h5&gt;&lt;h5 id=&quot;感觉博客还缺点功能、少点链接什么的，会再改一改&quot;&gt;&lt;a href=&quot;#感觉博客还缺点功能、少点链接什么的，会再改一改&quot; class=&quot;headerlink&quot; title=&quot;感觉博客还缺点功能、少点链接什么的，会再改一改~&quot;&gt;&lt;/a&gt;感觉博客还缺点功能、少点链接什么的，会再改一改~&lt;/h5&gt;
    
    </summary>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
    
  </entry>
  
</feed>
